{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"D:\\\\Vscode\\\\code\\\\React\\\\demo1\\\\src\\\\TicTacToe\\\\Game.js\";\nimport React, { Component } from 'react';\nimport Board from './Board'; // 使用slice()函数为每一步创建squares数组副本，同时把这个数组当作不可变对象，\n// 这样就可以把所有squares数组的历史版本都保存下来了，然后可以在历史的步骤中随意跳转\n// 把历史的squares数组保存在另一个名为history的数组中，history数组保存了从第一步到最后一步所有棋盘状态\n// 再次状态提升到Game组件，把state从Board组件提升到顶层的Game组件里，这样Game组件就拥有了对Board组件数据的完全控制权\n\nclass Game extends Component {\n  constructor(props) {\n    super(props);\n\n    this.calculateWinner = squares => {\n      const lines = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];\n\n      for (let i = 0; i < lines.length; i++) {\n        const [a, b, c] = lines[i];\n\n        if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n          return squares[a];\n        }\n      }\n\n      return null;\n    };\n\n    this.state = {\n      history: [{\n        squares: Array(9).fill(null)\n      }],\n      xIsNext: true,\n      // 这个值表示我们当前正在查看哪一项历史记录\n      stepNumber: 0\n    };\n  }\n\n  handleClick(i) {\n    // const history = this.state.history;\n    // 如果我们回到过去，再走一步新棋子，原来的历史记录就不正确了\n    // 这个替换可以保证我们把这些“未来”的不正确的历史记录丢掉\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const squares = current.squares.slice(); // 如果已经判断出胜利者或者该方格已经被点过了，就不能再点了\n\n    if (this.calculateWinner(squares) || squares[i]) {\n      return;\n    }\n\n    squares[i] = this.state.xIsNext ? 'X' : 'O';\n    this.setState({\n      history: history.concat([{\n        squares: squares\n      }]),\n      stepNumber: history.length,\n      xIsNext: !this.state.xIsNext\n    });\n  }\n\n  jumpTo(step) {\n    this.setState({\n      stepNumber: step,\n      xIsNext: step % 2 === 0\n    });\n  }\n\n  render() {\n    const history = this.state.history; // const current = history[history.length-1];\n\n    const current = history[this.state.stepNumber];\n    const winner = this.calculateWinner(current.squares);\n    const moves = history.map((step, move) => {\n      const desc = move ? 'GO TO MOVE#' + move : 'GO TO GAME START';\n      return (\n        /*#__PURE__*/\n        // 每当一个列表重新渲染时，react会根据每一项列表元素的key来检索上一次渲染时与每个key所匹配的列表项\n        // 只要构建动态列表的时候，都要指定一个合适的key\n        // 每一个历史步骤都有一个与之对应的唯一ID，这个ID就是每一步棋的序号\n        _jsxDEV(\"li\", {\n          children: /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => this.jumpTo(move),\n            children: desc\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 84,\n            columnNumber: 21\n          }, this)\n        }, move, false, {\n          fileName: _jsxFileName,\n          lineNumber: 83,\n          columnNumber: 17\n        }, this)\n      );\n    });\n    let status;\n\n    if (winner) {\n      status = 'Winner:' + winner;\n    } else {\n      status = 'Next player:' + (this.state.xIsNext ? 'X' : 'O');\n    }\n\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-board\",\n        children: /*#__PURE__*/_jsxDEV(Board, {\n          squares: current.squares,\n          onClick: i => this.handleClick(i)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 99,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 98,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          children: status\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 106,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n          children: moves\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 107,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 104,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default Game;","map":{"version":3,"sources":["D:/Vscode/code/React/demo1/src/TicTacToe/Game.js"],"names":["React","Component","Board","Game","constructor","props","calculateWinner","squares","lines","i","length","a","b","c","state","history","Array","fill","xIsNext","stepNumber","handleClick","slice","current","setState","concat","jumpTo","step","render","winner","moves","map","move","desc","status"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport Board from './Board'\r\n\r\n// 使用slice()函数为每一步创建squares数组副本，同时把这个数组当作不可变对象，\r\n// 这样就可以把所有squares数组的历史版本都保存下来了，然后可以在历史的步骤中随意跳转\r\n// 把历史的squares数组保存在另一个名为history的数组中，history数组保存了从第一步到最后一步所有棋盘状态\r\n// 再次状态提升到Game组件，把state从Board组件提升到顶层的Game组件里，这样Game组件就拥有了对Board组件数据的完全控制权\r\nclass Game extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { \r\n            history:[{\r\n                squares: Array(9).fill(null)\r\n            }],\r\n            xIsNext:true,\r\n            // 这个值表示我们当前正在查看哪一项历史记录\r\n            stepNumber: 0,\r\n        }\r\n    }\r\n\r\n    handleClick(i){\r\n        // const history = this.state.history;\r\n\r\n        // 如果我们回到过去，再走一步新棋子，原来的历史记录就不正确了\r\n        // 这个替换可以保证我们把这些“未来”的不正确的历史记录丢掉\r\n\r\n        const history = this.state.history.slice(0,this.state.stepNumber+1)\r\n        const current = history[history.length-1];\r\n        const squares = current.squares.slice();\r\n        // 如果已经判断出胜利者或者该方格已经被点过了，就不能再点了\r\n        if (this.calculateWinner(squares) || squares[i]){\r\n            return;\r\n        }\r\n        squares[i] = this.state.xIsNext?'X':'O';\r\n        this.setState({\r\n            history:history.concat([{\r\n                squares:squares\r\n            }]),\r\n            stepNumber: history.length,\r\n            xIsNext: !this.state.xIsNext,\r\n        })\r\n    }\r\n\r\n    jumpTo(step) {\r\n        this.setState({\r\n            stepNumber: step,\r\n            xIsNext: (step%2)===0\r\n        })\r\n    }\r\n\r\n    calculateWinner = (squares) =>{\r\n        const lines = [\r\n            [0,1,2],\r\n            [3,4,5],\r\n            [6,7,8],\r\n            [0,3,6],\r\n            [1,4,7],\r\n            [2,5,8],\r\n            [0,4,8],\r\n            [2,4,6],\r\n        ];\r\n        for (let i=0;i<lines.length;i++){\r\n            const [a,b,c] = lines[i];\r\n            if(squares[a] && squares[a]===squares[b] && squares[a]===squares[c]){\r\n                return squares[a];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    render() { \r\n        const history = this.state.history;\r\n        // const current = history[history.length-1];\r\n        const current = history[this.state.stepNumber]\r\n        const winner = this.calculateWinner(current.squares);\r\n\r\n        const moves = history.map((step,move)=>{\r\n            const desc = move ? 'GO TO MOVE#'+move : 'GO TO GAME START';\r\n            return (\r\n                // 每当一个列表重新渲染时，react会根据每一项列表元素的key来检索上一次渲染时与每个key所匹配的列表项\r\n                // 只要构建动态列表的时候，都要指定一个合适的key\r\n                // 每一个历史步骤都有一个与之对应的唯一ID，这个ID就是每一步棋的序号\r\n                <li key={move}>\r\n                    <button onClick={()=>this.jumpTo(move)}>{desc}</button>\r\n                </li>\r\n            )\r\n        })\r\n\r\n        let status;\r\n        if(winner){\r\n            status='Winner:'+winner;\r\n        }else{\r\n            status='Next player:' + (this.state.xIsNext?'X':'O');\r\n        }\r\n\r\n        return (\r\n            <div className=\"game\">\r\n                <div className=\"game-board\">\r\n                    <Board\r\n                        squares={current.squares}\r\n                        onClick={(i) => this.handleClick(i)}\r\n                    />\r\n                </div>\r\n                <div className=\"game-info\">\r\n                    {/* <Board /> */}\r\n                    <div>{status}</div>\r\n                    <ol>{moves}</ol>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n \r\nexport default Game;"]},"metadata":{},"sourceType":"module"}